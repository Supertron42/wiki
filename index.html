<!DOCTYPE html>
<html>
<head>
<title>MO2 Collections Wiki</title>
<style>
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}
body {
    font-family: Segoe UI, Arial, sans-serif;
    font-size: 13px;
    line-height: 1.6;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background: #1e1e1e;
    color: #d4d4d4;
}

.landing-container {
    text-align: center;
    padding: 40px;
}

h1 {
    font-size: 28px;
    color: #4ec9b0;
    margin-bottom: 10px;
}

.subtitle {
    color: #9cdcfe;
    font-size: 14px;
    margin-bottom: 40px;
}

.wiki-card {
    background: #252526;
    border: 1px solid #3c3c3c;
    border-radius: 8px;
    padding: 30px 40px;
    display: inline-block;
    transition: all 0.15s;
}
.wiki-card:hover {
    border-color: #569cd6;
    background: #2a2d2e;
    transform: translateY(-5px);
}

.wiki-card img {
    width: 80px;
    height: 80px;
    margin-bottom: 16px;
}

.wiki-card h2 {
    color: #4ec9b0;
    font-size: 18px;
    margin-bottom: 8px;
}

.wiki-card p {
    color: #9cdcfe;
    font-size: 12px;
    margin-bottom: 16px;
}

.wiki-card a {
    display: inline-block;
    background: #DA8E35;
    color: white;
    font-weight: bold;
    text-align: center;
    padding: 10px 24px;
    border-radius: 4px;
    text-decoration: none;
    font-size: 13px;
    transition: background 0.15s;
}
.wiki-card a:hover {
    background: #c47d2e;
}

@keyframes kofi-glow {
    0% { filter: drop-shadow(0 0 0px #ff5e5b); }
    50% { filter: drop-shadow(0 0 12px #ff5e5b); }
    100% { filter: drop-shadow(0 0 0px #ff5e5b); }
}
.kofi-btn:hover {
    animation: kofi-glow 0.6s ease-out;
}
</style>
</head>
<body>

<div class="landing-container">
    <!-- Space Game at top -->
    <div style="margin-bottom: 20px;">
        <div style="font-family: 'Courier New', monospace; font-size: 14px; font-weight: bold; letter-spacing: 2px; margin-bottom: 6px; display: flex; justify-content: center; gap: 30px;">
            <span id="scoreDisplay" style="color: #4ec9b0; text-shadow: 0 0 8px #4ec9b0;">SCORE: 0</span>
            <span id="highScoreDisplay" style="color: #ffff00; text-shadow: 0 0 8px #ffff00, 0 0 2px #ff8800; visibility: hidden;">PREVIOUS: 0</span>
        </div>
        <canvas id="gameCanvas" width="600" height="150" style="border: 1px solid #3c3c3c; border-radius: 8px; background: #0a0a12; cursor: none;"></canvas>
    </div>

    <h1>MO2 Collections Wiki</h1>
    <p class="subtitle">Documentation for MO2 plugin extensions and development tools</p>

    <div style="display: flex; gap: 24px; flex-wrap: wrap; justify-content: center;">
        <div class="wiki-card" style="border-color: #DA8E35; background: linear-gradient(rgba(0,0,0,0.75), rgba(0,0,0,0.75)), url('collectionsmanager/cm02thumbnail.webp') center/cover;">
            <h2 style="color: #fff;">Collections Manager</h2>
            <p style="color: #ddd;">Complete documentation for installing and managing Nexus collections in MO2.</p>
            <a href="collectionsmanager/wiki.html">Open Wiki</a>
        </div>

        <div class="wiki-card" style="border-color: #3D7EFF; background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.7)), url('clibdt/clibdt_bg.png') center/cover;">
            <img src="clibdt/clibdtthumbnail.webp" alt="ClibDT" style="width: 160px; height: 160px; margin-bottom: 16px; object-fit: contain;">
            <h2 style="color: #fff;">ClibDT</h2>
            <p style="color: #ddd;">CommonLib Developers Toolkit - lower the barrier to SKSE plugin development.</p>
            <a href="clibdt/wiki.html" style="background: #3D7EFF;">Open Wiki</a>
        </div>
    </div>

    <div style="margin-top: 40px; text-align: center;">
        <a href="https://ko-fi.com/supertron" target="_blank" class="kofi-btn"><img src="collectionsmanager/support on kofi.png" alt="Support me on Ko-fi" style="height: 36px;"></a>
    </div>
</div>

<script>
(function() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const highScoreDisplay = document.getElementById('highScoreDisplay');
    let lastScore = 0;

    // Audio context for retro sounds
    let audioCtx = null;
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    function playSound(freq, duration, type = 'square', vol = 0.1) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }
    function shootSound() { playSound(880, 0.08, 'square', 0.08); }
    function explodeSound() { playSound(150, 0.15, 'sawtooth', 0.1); }
    function powerupSound() {
        playSound(523, 0.1, 'square', 0.12);
        setTimeout(() => playSound(659, 0.1, 'square', 0.12), 80);
        setTimeout(() => playSound(784, 0.15, 'square', 0.12), 160);
    }
    function newHighScoreSound() {
        // Star Wars victory fanfare style
        playSound(392, 0.15, 'square', 0.15); // G
        setTimeout(() => playSound(523, 0.15, 'square', 0.15), 150); // C
        setTimeout(() => playSound(466, 0.1, 'square', 0.15), 300); // Bb
        setTimeout(() => playSound(523, 0.1, 'square', 0.15), 400); // C
        setTimeout(() => playSound(392, 0.1, 'square', 0.15), 500); // G
        setTimeout(() => playSound(523, 0.3, 'square', 0.15), 600); // C (hold)
        setTimeout(() => playSound(659, 0.4, 'square', 0.12), 750); // E (triumphant end)
    }
    function gameOverSound() {
        playSound(440, 0.15, 'square', 0.1);
        setTimeout(() => playSound(330, 0.15, 'square', 0.1), 150);
        setTimeout(() => playSound(220, 0.3, 'square', 0.1), 300);
    }

    let shipY = canvas.height / 2;
    let score = 0;
    let baseSpeed = 2;
    let bullets = [];
    let rocks = [];
    let explosions = [];
    let gameState = 'waiting'; // waiting, playing, gameOver
    let spawnTimer = null;
    let restartCountdown = 0;
    let beatPreviousScore = false;

    const ship = { x: 40, width: 24, height: 16 };

    canvas.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === canvas) {
            shipY += e.movementY;
        } else {
            const rect = canvas.getBoundingClientRect();
            shipY = e.clientY - rect.top;
        }
        shipY = Math.max(ship.height/2, Math.min(canvas.height - ship.height/2, shipY));
    });

    canvas.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // Left click only
        initAudio();

        if (gameState === 'waiting') {
            gameState = 'playing';
            canvas.requestPointerLock();
            spawnTimer = setInterval(spawnRock, 1000);
            return;
        }
        if (gameState === 'gameOver') {
            if (restartCountdown > 0) return;
            gameState = 'playing';
            canvas.requestPointerLock();
            score = 0;
            baseSpeed = 2;
            rocks = [];
            bullets = [];
            explosions = [];
            beatPreviousScore = false;
            scoreDisplay.textContent = 'SCORE: 0';
            spawnTimer = setInterval(spawnRock, 1000);
            return;
        }
        // Re-lock pointer if lost during gameplay
        if (document.pointerLockElement !== canvas) {
            canvas.requestPointerLock();
            return;
        }
        const shotCount = 1 + Math.floor(score / 5);
        for (let i = 0; i < shotCount; i++) {
            setTimeout(() => {
                if (gameState === 'playing') {
                    bullets.push({ x: ship.x + ship.width, y: shipY, speed: 10 });
                    shootSound();
                }
            }, i * 30);
        }
    });

    function spawnRock() {
        if (gameState !== 'playing') return;
        const size = 8 + Math.random() * 20;
        rocks.push({
            x: canvas.width + size,
            y: Math.random() * (canvas.height - size * 2) + size,
            radius: size,
            speed: baseSpeed + Math.random() * 1.5,
            rotation: Math.random() * Math.PI * 2,
            rotSpeed: (Math.random() - 0.5) * 0.1
        });
    }

    function explode(x, y) {
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 / 8) * i;
            explosions.push({ x, y, vx: Math.cos(angle) * 2.5, vy: Math.sin(angle) * 2.5, life: 15 });
        }
    }

    function drawShip() {
        ctx.fillStyle = '#4ec9b0';
        ctx.beginPath();
        ctx.moveTo(ship.x + ship.width, shipY);
        ctx.lineTo(ship.x, shipY - ship.height/2);
        ctx.lineTo(ship.x + 6, shipY);
        ctx.lineTo(ship.x, shipY + ship.height/2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#DA8E35';
        ctx.beginPath();
        ctx.moveTo(ship.x, shipY - 4);
        ctx.lineTo(ship.x - 8 - Math.random() * 4, shipY);
        ctx.lineTo(ship.x, shipY + 4);
        ctx.closePath();
        ctx.fill();
    }

    function drawRock(rock) {
        ctx.save();
        ctx.translate(rock.x, rock.y);
        ctx.rotate(rock.rotation);
        ctx.fillStyle = '#5a5a6a';
        ctx.strokeStyle = '#7a7a8a';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i < 7; i++) {
            const angle = (Math.PI * 2 / 7) * i;
            const r = rock.radius * (0.7 + Math.sin(i * 2.5) * 0.3);
            if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
            else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }

    function drawStartScreen() {
        ctx.fillStyle = '#4ec9b0';
        ctx.font = 'bold 16px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('Click to Start', canvas.width / 2, canvas.height / 2 + 5);
    }

    function drawGameOver() {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f44747';
        ctx.font = 'bold 18px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 10);
        ctx.fillStyle = '#fff';
        ctx.font = '14px Segoe UI';
        ctx.fillText('Final Score: ' + score, canvas.width / 2, canvas.height / 2 + 12);
        ctx.fillStyle = '#9cdcfe';
        ctx.font = '11px Segoe UI';
        if (restartCountdown > 0) {
            ctx.fillText('Restart in ' + restartCountdown + '...', canvas.width / 2, canvas.height / 2 + 30);
        } else {
            ctx.fillText('Click to restart', canvas.width / 2, canvas.height / 2 + 30);
        }
    }

    function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Stars
        ctx.fillStyle = '#ffffff22';
        for (let i = 0; i < 20; i++) {
            ctx.fillRect((i * 73 + Date.now() * 0.02) % canvas.width, (i * 37) % canvas.height, 1, 1);
        }

        if (gameState === 'waiting') {
            drawShip();
            drawStartScreen();
        } else if (gameState === 'playing') {
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bullets[i].speed;
                if (bullets[i].x > canvas.width) bullets.splice(i, 1);
            }

            // Update rocks
            for (let i = rocks.length - 1; i >= 0; i--) {
                const r = rocks[i];
                r.x -= r.speed;
                r.rotation += r.rotSpeed;

                // Bullet collision
                for (let bi = bullets.length - 1; bi >= 0; bi--) {
                    const b = bullets[bi];
                    const dx = b.x - r.x, dy = b.y - r.y;
                    if (Math.sqrt(dx*dx + dy*dy) < r.radius) {
                        explode(r.x, r.y);
                        explodeSound();
                        rocks.splice(i, 1);
                        bullets.splice(bi, 1);
                        const prevScore = score;
                        score++;
                        if (Math.floor(score / 5) > Math.floor(prevScore / 5)) {
                            powerupSound();
                        }
                        if (!beatPreviousScore && lastScore > 0 && score > lastScore) {
                            beatPreviousScore = true;
                            newHighScoreSound();
                        }
                        baseSpeed = 2 + score * 0.08;
                        scoreDisplay.textContent = 'SCORE: ' + score;
                        break;
                    }
                }

                // Ship collision
                if (rocks[i] && r.x - r.radius < ship.x + ship.width && r.x + r.radius > ship.x) {
                    if (r.y + r.radius > shipY - ship.height/2 && r.y - r.radius < shipY + ship.height/2) {
                        gameState = 'gameOver';
                        document.exitPointerLock();
                        clearInterval(spawnTimer);
                        lastScore = score;
                        highScoreDisplay.textContent = 'PREVIOUS: ' + lastScore;
                        highScoreDisplay.style.visibility = 'visible';
                        explode(ship.x + ship.width/2, shipY);
                        gameOverSound();
                        restartCountdown = 3;
                        const countdownInterval = setInterval(() => {
                            restartCountdown--;
                            if (restartCountdown <= 0) clearInterval(countdownInterval);
                        }, 1000);
                    }
                }

                if (rocks[i] && r.x + r.radius < 0) rocks.splice(i, 1);
            }

            drawShip();
        }

        // Update & draw explosions
        for (let i = explosions.length - 1; i >= 0; i--) {
            const e = explosions[i];
            e.x += e.vx; e.y += e.vy; e.life--;
            if (e.life <= 0) { explosions.splice(i, 1); continue; }
            ctx.fillStyle = `rgba(255, ${150 + e.life * 6}, 0, ${e.life / 15})`;
            ctx.beginPath();
            ctx.arc(e.x, e.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw bullets
        ctx.fillStyle = '#ffff00';
        bullets.forEach(b => ctx.fillRect(b.x, b.y - 1.5, 10, 3));

        // Draw rocks
        rocks.forEach(drawRock);

        if (gameState === 'gameOver') drawGameOver();

        requestAnimationFrame(update);
    }

    update();
})();
</script>
</body>
</html>
