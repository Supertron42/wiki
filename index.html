<!DOCTYPE html>
<html>
<head>
<title>MO2 Collections Wiki</title>
<style>
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}
body {
    font-family: Segoe UI, Arial, sans-serif;
    font-size: 13px;
    line-height: 1.6;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    background: #1e1e1e;
    color: #d4d4d4;
    padding-top: 30px;
}

.landing-container {
    text-align: center;
    padding: 40px;
}

h1 {
    font-size: 28px;
    color: #4ec9b0;
    margin-bottom: 10px;
}

.subtitle {
    color: #9cdcfe;
    font-size: 14px;
    margin-bottom: 40px;
}

.wiki-card {
    background: #252526;
    border: 1px solid #3c3c3c;
    border-radius: 8px;
    padding: 30px 40px;
    display: inline-flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: 320px;
    aspect-ratio: 16 / 9;
    transition: all 0.15s;
}
.wiki-card:hover {
    border-color: #569cd6;
    background: #2a2d2e;
    transform: translateY(-5px);
}

.wiki-card img {
    width: 80px;
    height: 80px;
    margin-bottom: 16px;
}

.wiki-card h2 {
    color: #4ec9b0;
    font-size: 18px;
    margin-bottom: 8px;
}

.wiki-card p {
    color: #9cdcfe;
    font-size: 12px;
    margin-bottom: 16px;
}

.wiki-card a {
    display: inline-block;
    background: #DA8E35;
    color: white;
    font-weight: bold;
    text-align: center;
    padding: 10px 24px;
    border-radius: 4px;
    text-decoration: none;
    font-size: 13px;
    transition: background 0.15s;
}
.wiki-card a:hover {
    background: #c47d2e;
}

.wiki-card {
    position: relative;
    overflow: hidden;
}
.lightning-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.1s;
    z-index: 10;
}
.wiki-card:hover .lightning-canvas {
    opacity: 1;
}
.kofi-container {
    position: relative;
    display: inline-block;
    overflow: visible;
}
@keyframes poop-fall {
    0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
    100% { transform: translateY(120px) rotate(360deg); opacity: 0; }
}
.poop-drop {
    position: absolute;
    font-size: 20px;
    pointer-events: none;
    animation: poop-fall 1s ease-in forwards;
    z-index: 100;
}
</style>
</head>
<body>

<div class="landing-container">
    <!-- Space Game at top -->
    <div style="margin-bottom: 20px;">
        <div style="font-family: 'Courier New', monospace; font-size: 14px; font-weight: bold; letter-spacing: 2px; margin-bottom: 6px; display: flex; justify-content: center; gap: 30px;">
            <span id="scoreDisplay" style="color: #4ec9b0; text-shadow: 0 0 8px #4ec9b0;">SCORE: 0</span>
            <span id="highScoreDisplay" style="color: #ffff00; text-shadow: 0 0 8px #ffff00, 0 0 2px #ff8800; visibility: hidden;">PREVIOUS: 0</span>
        </div>
        <canvas id="gameCanvas" width="600" height="150" style="border: 1px solid #3c3c3c; border-radius: 8px; background: #0a0a12; cursor: none;"></canvas>
    </div>

    <h1>Welcome to my Wiki</h1>
    <p class="subtitle">Enjoy your stay</p>

    <div style="display: flex; gap: 24px; flex-wrap: wrap; justify-content: center;">
        <div class="wiki-card" style="border-color: #DA8E35; background: linear-gradient(rgba(0,0,0,0.80), rgba(0,0,0,0.80)), url('collectionsmanager/cm02thumbnail.webp') center/cover;">
            <canvas class="lightning-canvas"></canvas>
            <h2 style="color: #fff;">Collections Manager</h2>
            <p style="color: #ddd;">Complete documentation for installing and managing Nexus collections in MO2.</p>
            <a href="collectionsmanager/wiki.html">Open Wiki</a>
        </div>

        <div class="wiki-card" style="border-color: #3D7EFF; background: linear-gradient(rgba(0,0,0,0.80), rgba(0,0,0,0.80)), url('clibdt/clibdt_bg.png') center/cover;">
            <canvas class="lightning-canvas"></canvas>
            <h2 style="color: #fff;">ClibDT</h2>
            <p style="color: #ddd;">CommonLib Developers Toolkit - lower the barrier to SKSE plugin development.</p>
            <a href="clibdt/wiki.html" style="background: #3D7EFF;">Open Wiki</a>
        </div>
    </div>

    <div style="margin-top: 40px; text-align: center;">
        <div class="kofi-container" id="kofiContainer">
            <a href="https://ko-fi.com/supertron" target="_blank" class="kofi-btn"><img src="collectionsmanager/support on kofi.png" alt="Support me on Ko-fi" style="height: 36px;"></a>
        </div>
    </div>
</div>

<script>
(function() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const highScoreDisplay = document.getElementById('highScoreDisplay');
    let lastScore = 0;

    // Audio context for retro sounds
    let audioCtx = null;
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    function playSound(freq, duration, type = 'square', vol = 0.1) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }
    function shootSound() { playSound(880, 0.08, 'square', 0.08); }
    function explodeSound() { playSound(150, 0.15, 'sawtooth', 0.1); }
    function powerupSound() {
        playSound(523, 0.1, 'square', 0.12);
        setTimeout(() => playSound(659, 0.1, 'square', 0.12), 80);
        setTimeout(() => playSound(784, 0.15, 'square', 0.12), 160);
    }
    function newHighScoreSound() {
        // Star Wars victory fanfare style
        playSound(392, 0.15, 'square', 0.15); // G
        setTimeout(() => playSound(523, 0.15, 'square', 0.15), 150); // C
        setTimeout(() => playSound(466, 0.1, 'square', 0.15), 300); // Bb
        setTimeout(() => playSound(523, 0.1, 'square', 0.15), 400); // C
        setTimeout(() => playSound(392, 0.1, 'square', 0.15), 500); // G
        setTimeout(() => playSound(523, 0.3, 'square', 0.15), 600); // C (hold)
        setTimeout(() => playSound(659, 0.4, 'square', 0.12), 750); // E (triumphant end)
    }
    function gameOverSound() {
        playSound(440, 0.15, 'square', 0.1);
        setTimeout(() => playSound(330, 0.15, 'square', 0.1), 150);
        setTimeout(() => playSound(220, 0.3, 'square', 0.1), 300);
    }

    let shipY = canvas.height / 2;
    let score = 0;
    let baseSpeed = 2;
    let bullets = [];
    let rocks = [];
    let explosions = [];
    let gameState = 'waiting'; // waiting, playing, gameOver
    let spawnTimer = null;
    let restartCountdown = 0;
    let beatPreviousScore = false;

    const ship = { x: 40, width: 24, height: 16 };

    canvas.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === canvas) {
            shipY += e.movementY;
        } else {
            const rect = canvas.getBoundingClientRect();
            shipY = e.clientY - rect.top;
        }
        shipY = Math.max(ship.height/2, Math.min(canvas.height - ship.height/2, shipY));
    });

    canvas.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // Left click only
        initAudio();

        if (gameState === 'waiting') {
            gameState = 'playing';
            canvas.requestPointerLock();
            spawnTimer = setInterval(spawnRock, 1000);
            return;
        }
        if (gameState === 'gameOver') {
            if (restartCountdown > 0) return;
            gameState = 'playing';
            canvas.requestPointerLock();
            score = 0;
            baseSpeed = 2;
            rocks = [];
            bullets = [];
            explosions = [];
            beatPreviousScore = false;
            scoreDisplay.textContent = 'SCORE: 0';
            spawnTimer = setInterval(spawnRock, 1000);
            return;
        }
        // Re-lock pointer if lost during gameplay
        if (document.pointerLockElement !== canvas) {
            canvas.requestPointerLock();
            return;
        }
        const shotCount = 1 + Math.floor(score / 5);
        for (let i = 0; i < shotCount; i++) {
            setTimeout(() => {
                if (gameState === 'playing') {
                    bullets.push({ x: ship.x + ship.width, y: shipY, speed: 10 });
                    shootSound();
                }
            }, i * 30);
        }
    });

    function spawnRock() {
        if (gameState !== 'playing') return;
        const size = 8 + Math.random() * 20;
        rocks.push({
            x: canvas.width + size,
            y: Math.random() * (canvas.height - size * 2) + size,
            radius: size,
            speed: baseSpeed + Math.random() * 1.5,
            rotation: Math.random() * Math.PI * 2,
            rotSpeed: (Math.random() - 0.5) * 0.1
        });
    }

    function explode(x, y) {
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 / 8) * i;
            explosions.push({ x, y, vx: Math.cos(angle) * 2.5, vy: Math.sin(angle) * 2.5, life: 15 });
        }
    }

    function drawShip() {
        ctx.fillStyle = '#4ec9b0';
        ctx.beginPath();
        ctx.moveTo(ship.x + ship.width, shipY);
        ctx.lineTo(ship.x, shipY - ship.height/2);
        ctx.lineTo(ship.x + 6, shipY);
        ctx.lineTo(ship.x, shipY + ship.height/2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#DA8E35';
        ctx.beginPath();
        ctx.moveTo(ship.x, shipY - 4);
        ctx.lineTo(ship.x - 8 - Math.random() * 4, shipY);
        ctx.lineTo(ship.x, shipY + 4);
        ctx.closePath();
        ctx.fill();
    }

    function drawRock(rock) {
        ctx.save();
        ctx.translate(rock.x, rock.y);
        ctx.rotate(rock.rotation);
        ctx.fillStyle = '#5a5a6a';
        ctx.strokeStyle = '#7a7a8a';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i < 7; i++) {
            const angle = (Math.PI * 2 / 7) * i;
            const r = rock.radius * (0.7 + Math.sin(i * 2.5) * 0.3);
            if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
            else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }

    function drawStartScreen() {
        ctx.fillStyle = '#4ec9b0';
        ctx.font = 'bold 16px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('Click to Start', canvas.width / 2, canvas.height / 2 + 5);
    }

    function drawGameOver() {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f44747';
        ctx.font = 'bold 18px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 10);
        ctx.fillStyle = '#fff';
        ctx.font = '14px Segoe UI';
        ctx.fillText('Final Score: ' + score, canvas.width / 2, canvas.height / 2 + 12);
        ctx.fillStyle = '#9cdcfe';
        ctx.font = '11px Segoe UI';
        if (restartCountdown > 0) {
            ctx.fillText('Restart in ' + restartCountdown + '...', canvas.width / 2, canvas.height / 2 + 30);
        } else {
            ctx.fillText('Click to restart', canvas.width / 2, canvas.height / 2 + 30);
        }
    }

    function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Stars
        ctx.fillStyle = '#ffffff22';
        for (let i = 0; i < 20; i++) {
            ctx.fillRect((i * 73 + Date.now() * 0.02) % canvas.width, (i * 37) % canvas.height, 1, 1);
        }

        if (gameState === 'waiting') {
            drawShip();
            drawStartScreen();
        } else if (gameState === 'playing') {
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bullets[i].speed;
                if (bullets[i].x > canvas.width) bullets.splice(i, 1);
            }

            // Update rocks
            for (let i = rocks.length - 1; i >= 0; i--) {
                const r = rocks[i];
                r.x -= r.speed;
                r.rotation += r.rotSpeed;

                // Bullet collision
                for (let bi = bullets.length - 1; bi >= 0; bi--) {
                    const b = bullets[bi];
                    const dx = b.x - r.x, dy = b.y - r.y;
                    if (Math.sqrt(dx*dx + dy*dy) < r.radius) {
                        explode(r.x, r.y);
                        explodeSound();
                        rocks.splice(i, 1);
                        bullets.splice(bi, 1);
                        const prevScore = score;
                        score++;
                        if (Math.floor(score / 5) > Math.floor(prevScore / 5)) {
                            powerupSound();
                        }
                        if (!beatPreviousScore && lastScore > 0 && score > lastScore) {
                            beatPreviousScore = true;
                            newHighScoreSound();
                        }
                        baseSpeed = 2 + score * 0.08;
                        scoreDisplay.textContent = 'SCORE: ' + score;
                        break;
                    }
                }

                // Ship collision
                if (rocks[i] && r.x - r.radius < ship.x + ship.width && r.x + r.radius > ship.x) {
                    if (r.y + r.radius > shipY - ship.height/2 && r.y - r.radius < shipY + ship.height/2) {
                        gameState = 'gameOver';
                        document.exitPointerLock();
                        clearInterval(spawnTimer);
                        lastScore = score;
                        highScoreDisplay.textContent = 'PREVIOUS: ' + lastScore;
                        highScoreDisplay.style.visibility = 'visible';
                        explode(ship.x + ship.width/2, shipY);
                        gameOverSound();
                        restartCountdown = 3;
                        const countdownInterval = setInterval(() => {
                            restartCountdown--;
                            if (restartCountdown <= 0) clearInterval(countdownInterval);
                        }, 1000);
                    }
                }

                if (rocks[i] && r.x + r.radius < 0) rocks.splice(i, 1);
            }

            drawShip();
        }

        // Update & draw explosions
        for (let i = explosions.length - 1; i >= 0; i--) {
            const e = explosions[i];
            e.x += e.vx; e.y += e.vy; e.life--;
            if (e.life <= 0) { explosions.splice(i, 1); continue; }
            ctx.fillStyle = `rgba(255, ${150 + e.life * 6}, 0, ${e.life / 15})`;
            ctx.beginPath();
            ctx.arc(e.x, e.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw bullets
        ctx.fillStyle = '#ffff00';
        bullets.forEach(b => ctx.fillRect(b.x, b.y - 1.5, 10, 3));

        // Draw rocks
        rocks.forEach(drawRock);

        if (gameState === 'gameOver') drawGameOver();

        requestAnimationFrame(update);
    }

    update();
})();

// Poop rain on kofi hover
(function() {
    const container = document.getElementById('kofiContainer');
    let poopInterval = null;

    function spawnPoop() {
        const poop = document.createElement('span');
        poop.className = 'poop-drop';
        poop.textContent = '\u{1F4A9}';
        poop.style.left = (Math.random() * 100) + '%';
        poop.style.top = '0';
        container.appendChild(poop);
        setTimeout(() => poop.remove(), 1000);
    }

    container.addEventListener('mouseenter', () => {
        poopInterval = setInterval(spawnPoop, 80);
    });

    container.addEventListener('mouseleave', () => {
        clearInterval(poopInterval);
    });
})();

// Lightning effect on card hover - strikes the Open Wiki button
(function() {
    const cards = document.querySelectorAll('.wiki-card');

    cards.forEach(card => {
        const canvas = card.querySelector('.lightning-canvas');
        const ctx = canvas.getContext('2d');
        const button = card.querySelector('a');
        let animationId = null;
        let bolts = [];
        let nextStrikeTime = 0;

        function resize() {
            canvas.width = card.offsetWidth;
            canvas.height = card.offsetHeight;
        }

        function getButtonCenter() {
            const cardRect = card.getBoundingClientRect();
            const btnRect = button.getBoundingClientRect();
            return {
                x: btnRect.left - cardRect.left + btnRect.width / 2,
                y: btnRect.top - cardRect.top + btnRect.height / 2
            };
        }

        function drawBolt(x1, y1, x2, y2, segments, seed) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);

            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const jitter = (1 - t) * 50; // More jitter at top, less near button
                const x = x1 + (x2 - x1) * t + (Math.sin(seed + i * 3) * jitter);
                const y = y1 + (y2 - y1) * t;
                ctx.lineTo(x, y);

                // Random branches
                if (i > 1 && i < segments - 2 && Math.sin(seed * i) > 0.5) {
                    ctx.moveTo(x, y);
                    const branchLen = 15 + Math.abs(Math.sin(seed * i * 2)) * 25;
                    const branchDir = Math.sin(seed * i) > 0 ? 1 : -1;
                    ctx.lineTo(x + branchDir * branchLen, y + 10);
                    ctx.moveTo(x, y);
                }
            }
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function spawnStrikes() {
            const btnPos = getButtonCenter();
            const numStrikes = 1 + Math.floor(Math.random() * 3); // 1-3 strikes

            for (let i = 0; i < numStrikes; i++) {
                const offsetX = (Math.random() - 0.5) * 40;
                bolts.push({
                    x1: btnPos.x + (Math.random() - 0.5) * 80,
                    y1: 0,
                    x2: btnPos.x + offsetX,
                    y2: btnPos.y,
                    life: 1,
                    segments: 6 + Math.floor(Math.random() * 4),
                    seed: Math.random() * 100
                });
            }
        }

        function animate(timestamp) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Spawn new strikes periodically
            if (timestamp > nextStrikeTime) {
                spawnStrikes();
                nextStrikeTime = timestamp + 400 + Math.random() * 600; // Every 400-1000ms
            }

            bolts.forEach(bolt => {
                // Main bolt - bright core
                ctx.strokeStyle = `rgba(255, 255, 255, ${bolt.life})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#aaccff';
                ctx.shadowBlur = 20;
                drawBolt(bolt.x1, bolt.y1, bolt.x2, bolt.y2, bolt.segments, bolt.seed);

                // Outer glow
                ctx.strokeStyle = `rgba(150, 180, 255, ${bolt.life * 0.6})`;
                ctx.lineWidth = 6;
                ctx.shadowBlur = 30;
                drawBolt(bolt.x1, bolt.y1, bolt.x2, bolt.y2, bolt.segments, bolt.seed);

                bolt.life -= 0.06;
            });

            bolts = bolts.filter(b => b.life > 0);
            ctx.shadowBlur = 0;

            animationId = requestAnimationFrame(animate);
        }

        card.addEventListener('mouseenter', () => {
            resize();
            bolts = [];
            nextStrikeTime = 0;
            animationId = requestAnimationFrame(animate);
        });

        card.addEventListener('mouseleave', () => {
            cancelAnimationFrame(animationId);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            bolts = [];
        });

        window.addEventListener('resize', resize);
    });
})();
</script>
</body>
</html>
